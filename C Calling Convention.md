# 什么是 Calling Convention

当在一个程序中结合使用更复杂的子程序时，会出现许多复杂的问题。例如，如何将参数传递给子程序？子程序能否覆盖寄存器中的值，还是调用者期望寄存器的内容保持不变？子程序中的局部变量应该存储在哪里？如何从函数中返回结果？

为了让不同的程序员可以共享代码并开发供多个程序使用的库，并简化子程序的使用，程序员通常会采用一个通用的**调用约定**。调用约定就是一套规则，它可以明确回答上述问题，从而简化子程序的定义和使用。例如，遵循一套调用约定规则，程序员不需要检查子程序的定义就能确定如何将参数传递给该子程序。此外，遵循一套调用约定规则，高级语言编译器可以被设计为遵循这些规则，从而允许手工编写的汇编语言程序和高级语言程序相互调用。

实际上，即使对于单一的处理器指令集，也可能存在多种调用约定。在本课程中，我们将研究并使用其中最重要的一个约定：C语言调用约定。理解这个约定将使你能够编写可以从C和C++代码中安全调用的汇编语言子程序，同时也能使你在汇编语言代码中调用C库函数。

# C Calling Convention
C语言的调用约定主要依赖于硬件支持的栈的使用。要理解C语言的调用约定，你首先应该确保你完全理解`push`、`pop`、`call`和`ret`指令——这些将是大多数规则的基础。在这种调用约定中，子程序的参数通过栈传递，寄存器保存在栈上，子程序使用的局部变量也放置在栈中的内存中。事实上，这种以栈为中心的子程序实现方式并不仅限于C语言或x86架构。绝大多数在各种处理器上实现的高级过程式语言都使用了类似的调用约定。

调用约定分为两组规则。第一组规则由子程序的调用者使用，第二组规则由子程序的编写者（即“被调用者”）遵循。需要强调的是，未能遵守这些规则会迅速导致致命的程序错误；因此，在自己的子程序中实现这些调用约定时，应当非常谨慎。
> **push**: 把一个值save到栈上。栈是一个先进后出的内存。RBP(EBP)指向栈底， RSP(ESP)指向栈顶。栈是从高地址向低地址长。
> 例如： **push eax**  ; RSP减8(在32-bit，ESP 减4) 同时把 EAX 地址存在栈上。

> **pop**: 从栈顶删掉一个值， 并把这个值放到寄存器里或者某个地址上。
> 例如：**pop ebx**  ; 把指定值拷贝到EBX 寄存器, RSP加8（在32-bit, ESP 加4。

> **call**: 用来调用一个函数。它会保存下一条指令(返回指令)到栈上， 然后跳到函数的地址去执行（把函数地址放到RIP/EIP 寄存器中）。
> 例如: **call my_function**  ; 把下一条指令地址放到栈上(返回地址)。 跳到 'my_function' 的地址去执行。

> **ret**: 从函数调用中返回， 保存在栈上的返回地址被放到RIP/EIP 中去继续执行。此时返回地址是在栈顶的。64-bit 上是**retq**。地址在64-bit上是8 byte， 在32-bit上是4 byte。
> 例如：ret  ; 从栈顶取出返回地址， 从这个地址继续执行。


# 调用函数Caller 的rule
1.  在调用另一个函数之前， caller 需要把一些**保存着caller 使用data的寄存器的内容push到栈上**。 这些寄存器包括 r10, r11 和其他的一些保存参数的寄存器。这些内容往往是在调用另一个函数后还需要保持不变的。
2.  把被调用函数需要的**参数放到6个寄存器中**。如果函数参数超过了6个， 把其他的参数以相反的顺序压到栈上。
	> 六个寄存器依次是:
	> **rdi**: 第一个参数
	> **rsi**: 第二个参数
	> **rdx**: 第三个参数
	> **rcx**: 第四个参数
	> **r8**: 第五个参数
	> **r9**: 第六个参数

3.  **用 call 指令去调用被调用函数**。 返回地址（下一条指令地址）会被push到栈上， 然后跳到被调用函数的地址去执行。
4. 在从被调用函数返回后（紧跟着）
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU0NjE5NzY5NiwtNTc1OTY3OTMwLDE2OD
QyMzY4MTAsMTM2NzYzODQ3MywtMjY3MjA0NDUwLC0xMzI3Nzky
ODE2LC01NjI1NjkxMjAsMjExNjY2OTk4Ml19
-->